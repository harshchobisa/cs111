Total: 332 samples
     260  78.3%  78.3%      332 100.0% thread_function_for_list
      13   3.9%  82.2%       13   3.9% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:200
      13   3.9%  86.1%       46  13.9% SortedList_insert
      10   3.0%  89.2%       26   7.8% SortedList_lookup
       5   1.5%  90.7%        5   1.5% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:1720
       5   1.5%  92.2%        5   1.5% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:1730
       4   1.2%  93.4%        4   1.2% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:1721
       4   1.2%  94.6%        4   1.2% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:1729
       4   1.2%  95.8%        4   1.2% _init
       3   0.9%  96.7%        3   0.9% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:130
       3   0.9%  97.6%        3   0.9% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:160
       2   0.6%  98.2%        2   0.6% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:165
       2   0.6%  98.8%        2   0.6% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:202
       2   0.6%  99.4%        2   0.6% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:203
       2   0.6% 100.0%        2   0.6% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:205
       0   0.0% 100.0%      332 100.0% ?? /usr/src/debug////////glibc-2.17-c758a686/misc/../sysdeps/unix/sysv/linux/x86_64/clone.S:111
       0   0.0% 100.0%      332 100.0% start_thread
ROUTINE ====================== thread_function_for_list in /u/cs/ugrad/harsh/cs111/twob/lab2_list.c
   260    332 Total samples (flat / cumulative)
     .      .   31:   fprintf(stderr, "Segmentation fault found\n");
     .      .   32:   exit(2);
     .      .   33: }
     .      .   34: 
     .      .   35: void *thread_function_for_list(void *position)
---
     .      .   36: {
     .      .   37: 
     .      .   38:   int offsetfac = *((int *)position);
     .      .   39:   int x = offsetfac;
     .      .   40:   int limit = offsetfac + iterationsNum;
     .      .   41:   int lockIndex = offsetfac/iterationsNum;
     .      .   42: 
     .      .   43:   struct timespec startIns;
     .      .   44:   struct timespec finalIns;
     .      .   45:   unsigned int index = 0;
     .      .   46:   long long total = 0;
     .      .   47: 
     .      .   48:   for (; x < limit; x++)
     .      .   49:   {
     .      .   50:     index = hashFunction(listNodes[x].key);
     .      .   51:     switch (sync)
     .      .   52:     {
     .      .   53:     case '0':
     .      .   54:       // fprintf(stderr, "test");
     .      .   55:       SortedList_insert(&listHeads[index], &listNodes[x]);
     .      .   56:       break;
     .      .   57:     case 'm':
     .      .   58:       clock_gettime(CLOCK_MONOTONIC, &startIns);
     .      .   59:       pthread_mutex_lock(&mutexLock[index]);
     .      .   60:       clock_gettime(CLOCK_MONOTONIC, &finalIns);
     .      .   61:       SortedList_insert(&listHeads[index], &listNodes[x]);
     .      .   62:       pthread_mutex_unlock(&mutexLock[index]);
     .      .   63:       break;
     .      .   64:     case 's':
     .      .   65:       clock_gettime(CLOCK_MONOTONIC, &startIns);
   196    196   66:       while (__sync_lock_test_and_set(&spinLock[index], 1));
     .      .   67:       clock_gettime(CLOCK_MONOTONIC, &finalIns);
     .     46   68:       SortedList_insert(&listHeads[index], &listNodes[x]);
     .      .   69:       __sync_lock_release(&spinLock[index]);
     .      .   70:       break;
     .      .   71:     }
     .      .   72:     if (sync != '0')
     .      .   73:     {
     .      .   74:       total += billion * (finalIns.tv_sec - startIns.tv_sec) + (finalIns.tv_nsec - startIns.tv_nsec);
     .      .   75:     }
     .      .   76:   }
     .      .   77: 
     .      .   78:   struct timespec startLen;
     .      .   79:   struct timespec finalLen;
     .      .   80:   switch (sync)
     .      .   81:   {
     .      .   82:   case '0':
     .      .   83: 
     .      .   84:     for (x = 0; x < listHeadsNum; x++)
     .      .   85:     {
     .      .   86:       int len = SortedList_length(&listHeads[x]);
     .      .   87:       if (len < 0)
     .      .   88:       {
     .      .   89:         fprintf(stderr, "Error, the list length can never be negative\n");
     .      .   90:         exit(2);
     .      .   91:       }
     .      .   92:     }
     .      .   93:     break;
     .      .   94:   case 'm':
     .      .   95:     for (x = 0; x < listHeadsNum; x++)
     .      .   96:     {
     .      .   97:       clock_gettime(CLOCK_MONOTONIC, &startLen);
     .      .   98:       pthread_mutex_lock(&mutexLock[x]);
     .      .   99:       clock_gettime(CLOCK_MONOTONIC, &finalLen);
     .      .  100:       int len = SortedList_length(&listHeads[x]);
     .      .  101:       pthread_mutex_unlock(&mutexLock[x]);
     .      .  102:       if (len < 0)
     .      .  103:       {
     .      .  104:         fprintf(stderr, "Error, the list length can never be negative\n");
     .      .  105:         exit(2);
     .      .  106:       }
     .      .  107:     }
     .      .  108:     break;
     .      .  109:   case 's':
     .      .  110:     for (x = 0; x < listHeadsNum; x++)
     .      .  111:     {
     .      .  112:       clock_gettime(CLOCK_MONOTONIC, &startLen);
     .      .  113:       while (__sync_lock_test_and_set(&spinLock[x], 1));
     .      .  114:       clock_gettime(CLOCK_MONOTONIC, &finalLen);
     .      .  115:       int len = SortedList_length(&listHeads[x]);
     .      .  116:       __sync_lock_release(&spinLock[x]);
     .      .  117:       if (len < 0)
     .      .  118:       {
     .      .  119:         fprintf(stderr, "Error, the list length can never be negative\n");
     .      .  120:         exit(2);
     .      .  121:       }
     .      .  122:     }
     .      .  123:     break;
     .      .  124:   }
     .      .  125:   if (sync != '0')
     .      .  126:   {
     .      .  127:     total += billion * (finalLen.tv_sec - startLen.tv_sec) + (finalLen.tv_nsec - startLen.tv_nsec);
     .      .  128:   }
     .      .  129: 
     .      .  130:   struct timespec startDel;
     .      .  131:   struct timespec finalDel;
     .      .  132: 
     .      .  133:   for (x = offsetfac; x < limit; x++)
     .      .  134:   {
     .      .  135:     index = hashFunction(listNodes[x].key);
     .      .  136:     switch (sync)
     .      .  137:     {
     .      .  138:     case '0':
     .      .  139:       if (SortedList_delete(SortedList_lookup(&listHeads[index], listNodes[x].key)))
     .      .  140:       {
     .      .  141:         fprintf(stderr, "Error deleting element.\n");
     .      .  142:         exit(2);
     .      .  143:       }
     .      .  144:       break;
     .      .  145:     case 'm':
     .      .  146:       clock_gettime(CLOCK_MONOTONIC, &startDel);
     .      .  147:       pthread_mutex_lock(&mutexLock[index]);
     .      .  148:       clock_gettime(CLOCK_MONOTONIC, &finalDel);
     .      .  149:       if (SortedList_delete(SortedList_lookup(&listHeads[index], listNodes[x].key)))
     .      .  150:       {
     .      .  151:         fprintf(stderr, "Error deleting element.\n");
     .      .  152:         exit(2);
     .      .  153:       }
     .      .  154:       pthread_mutex_unlock(&mutexLock[index]);
     .      .  155:       break;
     .      .  156:     case 's':
     .      .  157:       clock_gettime(CLOCK_MONOTONIC, &startDel);
    64     64  158:       while (__sync_lock_test_and_set(&spinLock[index], 1))
     .      .  159:         ;
     .      .  160:       clock_gettime(CLOCK_MONOTONIC, &finalDel);
     .     26  161:       if (SortedList_delete(SortedList_lookup(&listHeads[index], listNodes[x].key)))
     .      .  162:       {
     .      .  163:         fprintf(stderr, "Error deleting element.\n");
     .      .  164:         exit(2);
     .      .  165:       }
     .      .  166:       __sync_lock_release(&spinLock[index]);
     .      .  167:       break;
     .      .  168:     }
     .      .  169:     if (sync != '0')
     .      .  170:     {
     .      .  171:       total += billion * (finalDel.tv_sec - startDel.tv_sec) + (finalDel.tv_nsec - startDel.tv_nsec);
     .      .  172:     }
     .      .  173:   }
     .      .  174:   lockDelay[lockIndex] += total;
     .      .  175:   return NULL;
     .      .  176: }
---
     .      .  177: 
     .      .  178: struct option getOptStruct[] =
     .      .  179:     {
     .      .  180:         {"threadsNum", 1, 0, 1},
     .      .  181:         {"iterationsNum", 1, 0, 2},
ROUTINE ====================== thread_function_for_list in /u/cs/ugrad/harsh/cs111/twob/lab2_list.c
   260    332 Total samples (flat / cumulative)
     .      .   31:   fprintf(stderr, "Segmentation fault found\n");
     .      .   32:   exit(2);
     .      .   33: }
     .      .   34: 
     .      .   35: void *thread_function_for_list(void *position)
---
     .      .   36: {
     .      .   37: 
     .      .   38:   int offsetfac = *((int *)position);
     .      .   39:   int x = offsetfac;
     .      .   40:   int limit = offsetfac + iterationsNum;
     .      .   41:   int lockIndex = offsetfac/iterationsNum;
     .      .   42: 
     .      .   43:   struct timespec startIns;
     .      .   44:   struct timespec finalIns;
     .      .   45:   unsigned int index = 0;
     .      .   46:   long long total = 0;
     .      .   47: 
     .      .   48:   for (; x < limit; x++)
     .      .   49:   {
     .      .   50:     index = hashFunction(listNodes[x].key);
     .      .   51:     switch (sync)
     .      .   52:     {
     .      .   53:     case '0':
     .      .   54:       // fprintf(stderr, "test");
     .      .   55:       SortedList_insert(&listHeads[index], &listNodes[x]);
     .      .   56:       break;
     .      .   57:     case 'm':
     .      .   58:       clock_gettime(CLOCK_MONOTONIC, &startIns);
     .      .   59:       pthread_mutex_lock(&mutexLock[index]);
     .      .   60:       clock_gettime(CLOCK_MONOTONIC, &finalIns);
     .      .   61:       SortedList_insert(&listHeads[index], &listNodes[x]);
     .      .   62:       pthread_mutex_unlock(&mutexLock[index]);
     .      .   63:       break;
     .      .   64:     case 's':
     .      .   65:       clock_gettime(CLOCK_MONOTONIC, &startIns);
   196    196   66:       while (__sync_lock_test_and_set(&spinLock[index], 1));
     .      .   67:       clock_gettime(CLOCK_MONOTONIC, &finalIns);
     .     46   68:       SortedList_insert(&listHeads[index], &listNodes[x]);
     .      .   69:       __sync_lock_release(&spinLock[index]);
     .      .   70:       break;
     .      .   71:     }
     .      .   72:     if (sync != '0')
     .      .   73:     {
     .      .   74:       total += billion * (finalIns.tv_sec - startIns.tv_sec) + (finalIns.tv_nsec - startIns.tv_nsec);
     .      .   75:     }
     .      .   76:   }
     .      .   77: 
     .      .   78:   struct timespec startLen;
     .      .   79:   struct timespec finalLen;
     .      .   80:   switch (sync)
     .      .   81:   {
     .      .   82:   case '0':
     .      .   83: 
     .      .   84:     for (x = 0; x < listHeadsNum; x++)
     .      .   85:     {
     .      .   86:       int len = SortedList_length(&listHeads[x]);
     .      .   87:       if (len < 0)
     .      .   88:       {
     .      .   89:         fprintf(stderr, "Error, the list length can never be negative\n");
     .      .   90:         exit(2);
     .      .   91:       }
     .      .   92:     }
     .      .   93:     break;
     .      .   94:   case 'm':
     .      .   95:     for (x = 0; x < listHeadsNum; x++)
     .      .   96:     {
     .      .   97:       clock_gettime(CLOCK_MONOTONIC, &startLen);
     .      .   98:       pthread_mutex_lock(&mutexLock[x]);
     .      .   99:       clock_gettime(CLOCK_MONOTONIC, &finalLen);
     .      .  100:       int len = SortedList_length(&listHeads[x]);
     .      .  101:       pthread_mutex_unlock(&mutexLock[x]);
     .      .  102:       if (len < 0)
     .      .  103:       {
     .      .  104:         fprintf(stderr, "Error, the list length can never be negative\n");
     .      .  105:         exit(2);
     .      .  106:       }
     .      .  107:     }
     .      .  108:     break;
     .      .  109:   case 's':
     .      .  110:     for (x = 0; x < listHeadsNum; x++)
     .      .  111:     {
     .      .  112:       clock_gettime(CLOCK_MONOTONIC, &startLen);
     .      .  113:       while (__sync_lock_test_and_set(&spinLock[x], 1));
     .      .  114:       clock_gettime(CLOCK_MONOTONIC, &finalLen);
     .      .  115:       int len = SortedList_length(&listHeads[x]);
     .      .  116:       __sync_lock_release(&spinLock[x]);
     .      .  117:       if (len < 0)
     .      .  118:       {
     .      .  119:         fprintf(stderr, "Error, the list length can never be negative\n");
     .      .  120:         exit(2);
     .      .  121:       }
     .      .  122:     }
     .      .  123:     break;
     .      .  124:   }
     .      .  125:   if (sync != '0')
     .      .  126:   {
     .      .  127:     total += billion * (finalLen.tv_sec - startLen.tv_sec) + (finalLen.tv_nsec - startLen.tv_nsec);
     .      .  128:   }
     .      .  129: 
     .      .  130:   struct timespec startDel;
     .      .  131:   struct timespec finalDel;
     .      .  132: 
     .      .  133:   for (x = offsetfac; x < limit; x++)
     .      .  134:   {
     .      .  135:     index = hashFunction(listNodes[x].key);
     .      .  136:     switch (sync)
     .      .  137:     {
     .      .  138:     case '0':
     .      .  139:       if (SortedList_delete(SortedList_lookup(&listHeads[index], listNodes[x].key)))
     .      .  140:       {
     .      .  141:         fprintf(stderr, "Error deleting element.\n");
     .      .  142:         exit(2);
     .      .  143:       }
     .      .  144:       break;
     .      .  145:     case 'm':
     .      .  146:       clock_gettime(CLOCK_MONOTONIC, &startDel);
     .      .  147:       pthread_mutex_lock(&mutexLock[index]);
     .      .  148:       clock_gettime(CLOCK_MONOTONIC, &finalDel);
     .      .  149:       if (SortedList_delete(SortedList_lookup(&listHeads[index], listNodes[x].key)))
     .      .  150:       {
     .      .  151:         fprintf(stderr, "Error deleting element.\n");
     .      .  152:         exit(2);
     .      .  153:       }
     .      .  154:       pthread_mutex_unlock(&mutexLock[index]);
     .      .  155:       break;
     .      .  156:     case 's':
     .      .  157:       clock_gettime(CLOCK_MONOTONIC, &startDel);
    64     64  158:       while (__sync_lock_test_and_set(&spinLock[index], 1))
     .      .  159:         ;
     .      .  160:       clock_gettime(CLOCK_MONOTONIC, &finalDel);
     .     26  161:       if (SortedList_delete(SortedList_lookup(&listHeads[index], listNodes[x].key)))
     .      .  162:       {
     .      .  163:         fprintf(stderr, "Error deleting element.\n");
     .      .  164:         exit(2);
     .      .  165:       }
     .      .  166:       __sync_lock_release(&spinLock[index]);
     .      .  167:       break;
     .      .  168:     }
     .      .  169:     if (sync != '0')
     .      .  170:     {
     .      .  171:       total += billion * (finalDel.tv_sec - startDel.tv_sec) + (finalDel.tv_nsec - startDel.tv_nsec);
     .      .  172:     }
     .      .  173:   }
     .      .  174:   lockDelay[lockIndex] += total;
     .      .  175:   return NULL;
     .      .  176: }
---
     .      .  177: 
     .      .  178: struct option getOptStruct[] =
     .      .  179:     {
     .      .  180:         {"threadsNum", 1, 0, 1},
     .      .  181:         {"iterationsNum", 1, 0, 2},
